from casadi import *
import numpy as np
from numpy import linalg as LA
import math

# Define the multilift dynamics model, specific for open-loop tension optimal allocation
# Dr. Wang Bingheng, C&S Lab, 16-Dec-2024

class multilift_model:
    def __init__(self, sysm_para, dt_sample):
        # Payload's parameters
        self.m1     = sysm_para[0] # the payload's mass [kg]
        self.m2     = sysm_para[1] # the added mass [kg]
        self.Jlcom  = np.diag(sysm_para[1:4]) # rotational inertia of m1 about its Geometric Center (GC)
        self.ml     = self.m1 + self.m2
        # Payload's state and control
        self.pl     = SX.sym('pl',3,1) # position of center-of-mass (COM) of the payload in {I}
        self.vl     = SX.sym('vl',3,1) # velocity of CO in {I}
        self.ql     = SX.sym('ql',4,1) # quaternion of payload
        self.wl     = SX.sym('wl',3,1) # angular velocity in {Bl}
        self.xl     = vertcat(self.pl, self.vl, self.ql, self.wl) # 13-by-1 vector
        self.nxl    = self.xl.numel()
        self.Fl     = SX.sym('Fl',3,1) # total control force in {I}, generated by all the tension forces
        self.Ml     = SX.sym('Ml',3,1) # total control torque in {Bl}, generated by all the tension forces
        self.Wl     = vertcat(self.Fl,self.Ml) # control wrench, 6-by-1 vector
        self.nWl    = self.Wl.numel()
        # Gravitational acceleration 
        self.g      = 9.81
        # Unit direction vectors free of coordinate
        self.ex     = vertcat(1, 0, 0)
        self.ey     = vertcat(0, 1, 0)
        self.ez     = vertcat(0, 0, 1)
        # Simulation time step used in MPC
        self.dt     = dt_sample
        # Polynomial coefficients of reference trajectory
        self.polyc = SX.sym('c',1,8)
        # Time in polynomial
        self.time  = SX.sym('t')
        # Initial time in polynomial
        self.time0 = SX.sym('t0')

    def Rotational_Inertia(self,rp):
        # rp=(x,y,0), a column vector, is the coordinate of the point-mass added on the uniform circular plate in its body frame 
        ratio_m    = self.m1*self.m2/self.ml
        self.Jl    = self.Jlcom + ratio_m*(rp.T@rp*np.identity(3)-rp@rp.T)

    def dir_cosine(self, Euler):
        # Euler angles for roll, pitch and yaw
        gamma, theta, psi = Euler[0,0], Euler[1,0], Euler[2,0]
        R_x = np.array([[1, 0, 0],
                        [0, math.cos(gamma), math.sin(gamma)],
                        [0, -math.sin(gamma),  math.cos(gamma)]])
        R_y = np.array([[ math.cos(theta), 0, -math.sin(theta)],
                        [0,                1,              0],
                        [math.sin(theta), 0, math.cos(theta)]])
        R_z = np.array([[math.cos(psi), math.sin(psi), 0],
                        [-math.sin(psi),  math.cos(psi), 0],
                        [0,                          0, 1]])
        # Rotation matrix from world frame to body frame, X->Z->Y
        R_wb= np.matmul(np.matmul(R_y, R_z), R_x)
        # Rotation matrix from body frame to world frame, Y->Z->X
        R_bw= np.transpose(R_wb)
        return R_bw

    def skew_sym(self, v): # skew-symmetric operator
        v_cross = vertcat(
            horzcat(0, -v[2,0], v[1,0]),
            horzcat(v[2,0], 0, -v[0,0]),
            horzcat(-v[1,0], v[0,0], 0)
        )
        return v_cross
    
    
    def chol_solve(self,L, B):
        # Solve (L L^T) X = B
        Y = LA.solve(L, B)
        return LA.solve(L.T, Y)

    def try_cholesky(self,A, jitter0=0.0, max_tries=5):
        """Try Cholesky with growing jitter on the diagonal."""
        jitter = jitter0
        for _ in range(max_tries):
            try:
                return LA.cholesky(A + jitter*np.eye(A.shape[0])), jitter
            except LA.LinAlgError:
                jitter = max(1e-12, 10*(jitter if jitter>0 else 1e-12))
        raise LA.LinAlgError("Cholesky failed even with jitter")


    def q_2_rotation(self, q): # from body frame to inertial frame
        q0, q1, q2, q3 = q[0,0], q[1,0], q[2,0], q[3,0] # q0 denotes a scalar while q1, q2, and q3 represent rotational axes x, y, and z, respectively
        R = vertcat(
        horzcat( 2 * (q0 ** 2 + q1 ** 2) - 1, 2 * q1 * q2 - 2 * q0 * q3, 2 * q0 * q2 + 2 * q1 * q3),
        horzcat(2 * q0 * q3 + 2 * q1 * q2, 2 * (q0 ** 2 + q2 ** 2) - 1, 2 * q2 * q3 - 2 * q0 * q1),
        horzcat(2 * q1 * q3 - 2 * q0 * q2, 2 * q0 * q1 + 2 * q2 * q3, 2 * (q0 ** 2 + q3 ** 2) - 1)
        )
        return R
    
    
    def payload_dyn(self, xl, ul):
        """
        Use the following cable attachment settings:
        configuration of the payload tether attachment points:
        start from the first point [rl;0;0]
        allocate the remaining attachment points anticlockwisely
        the separation angle between any two neighbouring attachment points is defined by alpha = 2*pi/nq
        the coordinate of the n-th attachment point is [rl*cos((n-1)*alpha);rl*sin((n-1)*alpha);0]
        ----------------------------------------------------------------------------------------
        We temporarily treat the load as a 6-DoF rigid body controlled by a 6-by-1 wrench vector
        """
        """
        6-DOF Rigid body dyanmics about the COM
        """
        # Position in {I}
        pl      = vertcat(xl[0,0], xl[1,0], xl[2,0])
        # Velocity in {I}
        vl      = vertcat(xl[3,0], xl[4,0], xl[5,0])
        # Quaternion
        ql      = vertcat(xl[6,0], xl[7,0], xl[8,0], xl[9,0])
        # Angular velocity in {Bl}
        wl      = vertcat(xl[10,0], xl[11,0], xl[12,0])
        # Cable forces and torques
        Fl      = vertcat(ul[0,0], ul[1,0], ul[2,0]) # in {I}
        Mtl     = vertcat(ul[3,0], ul[4,0], ul[5,0])
        # Kinematics
        dpl     = vl
        dvl     = -self.g*self.ez + 1/self.ml * Fl # model defined at the COM
        S_wl    = self.skew_sym(wl)
        omega   = vertcat(
            horzcat(0, -wl.T),
            horzcat(wl,-S_wl)
        )
        dql     = 1/2*omega@ql
        dwl     = LA.inv(self.Jl)@(Mtl-S_wl@(self.Jl@wl))
        # Model
        model_l = vertcat(dpl, dvl, dql, dwl)

        return model_l

    def model(self):
        # Payload: 4-th order Runge-Kutta discretization of the model used in MPC (symbolic computation)
        k1l     = self.payload_dyn(self.xl, self.Wl) 
        k2l     = self.payload_dyn(self.xl + self.dt/2*k1l, self.Wl)
        k3l     = self.payload_dyn(self.xl + self.dt/2*k2l, self.Wl)
        k4l     = self.payload_dyn(self.xl + self.dt*k3l, self.Wl)
        self.model_l = (k1l + 2*k2l + 2*k3l + k4l)/6


    # polynomial trajectories
    def polytraj(self,coeff,time,time0):
        time_vec   = vertcat(1,
                             self.time-self.time0,
                             (self.time-self.time0)**2,
                             (self.time-self.time0)**3,
                             (self.time-self.time0)**4,
                             (self.time-self.time0)**5,
                             (self.time-self.time0)**6,
                             (self.time-self.time0)**7)
        polyp      = mtimes(self.polyc, time_vec)
        polyp_fn   = Function('ref_p',[self.polyc,self.time,self.time0],[polyp],['pc0','t0','ti0'],['ref_pf'])
        ref_p      = polyp_fn(pc0=coeff,t0=time,ti0=time0)['ref_pf'].full()
        polyv      = jacobian(polyp, self.time)
        polyv_fn   = Function('ref_v',[self.polyc,self.time,self.time0],[polyv],['pc0','t0','ti0'],['ref_vf'])
        ref_v      = polyv_fn(pc0=coeff,t0=time,ti0=time0)['ref_vf'].full()
        polya      = jacobian(polyv, self.time)
        polya_fn   = Function('ref_a',[self.polyc,self.time,self.time0],[polya],['pc0','t0','ti0'],['ref_af'])
        ref_a      = polya_fn(pc0=coeff,t0=time,ti0=time0)['ref_af'].full()
        polyj      = jacobian(polya, self.time)
        polyj_fn   = Function('ref_j',[self.polyc,self.time,self.time0],[polyj],['pc0','t0','ti0'],['ref_jf'])
        ref_j      = polyj_fn(pc0=coeff,t0=time,ti0=time0)['ref_jf'].full()
        polys      = jacobian(polyj, self.time)
        polys_fn   = Function('ref_s',[self.polyc,self.time,self.time0],[polys],['pc0','t0','ti0'],['ref_sf'])
        ref_s      = polys_fn(pc0=coeff,t0=time,ti0=time0)['ref_sf'].full()

        return ref_p, ref_v, ref_a, ref_j, ref_s
    
    def minisnap_load_circle(self,Coeffx,Coeffy,Coeffz,time,rg): # 3 trajectories
        t_switch = 0
        t1 = 2.4 # for tf = 4s
        if time <t1:
            ref_px, ref_vx, ref_ax, ref_jx, ref_sx = self.polytraj(Coeffx[0,:],time,t_switch)
            ref_py, ref_vy, ref_ay, ref_jy, ref_sy = self.polytraj(Coeffy[0,:],time,t_switch)
            ref_pz, ref_vz, ref_az, ref_jz, ref_sz = self.polytraj(Coeffz[0,:],time,t_switch)
       
        else:
            ref_px, ref_vx, ref_ax, ref_jx, ref_sx = self.polytraj(Coeffx[1,:],time,t1+t_switch)
            ref_py, ref_vy, ref_ay, ref_jy, ref_sy = self.polytraj(Coeffy[1,:],time,t1+t_switch)
            ref_pz, ref_vz, ref_az, ref_jz, ref_sz = self.polytraj(Coeffz[1,:],time,t1+t_switch)
        ref_p = np.reshape(np.vstack((ref_px, ref_py, ref_pz)), (3,1))+np.reshape(np.vstack((rg[0],rg[1],0)),(3,1))
        ref_v = np.reshape(np.vstack((ref_vx, ref_vy, ref_vz)), (3,1))
        ref_q = np.array([[1,0,0,0]]).T
        ref_w = np.zeros((3,1))
        ref_xl= np.reshape(np.vstack((ref_p,ref_v,ref_q,ref_w)),self.nxl)
        ref_a = np.reshape(np.vstack((ref_ax, ref_ay, ref_az)), (3,1))
        ref_Fl= self.ml*(ref_a + self.g*self.ez) # reference force in the load's desired body frame (Rl = identity matrix)
        ref_ml= np.zeros((3,1)) # reference torque in the load's desired body frame
        ref_Wl= np.reshape(np.vstack((ref_Fl,ref_ml)),self.nWl)
        return ref_xl, ref_Wl
    

    
    