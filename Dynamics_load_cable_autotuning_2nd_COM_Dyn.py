from casadi import *
import numpy as np
from numpy import linalg as LA
import math

# Define the multilift dynamics model, including the dynamics of the load and the cables
# Dr. Wang Bingheng, C&S Lab, 19-Feb-2025

class multilift_model:
    def __init__(self, sysm_para, dt_sample):
        # Payload's parameters
        self.m1     = sysm_para[0] # the payload's mass [kg]
        self.m2     = sysm_para[1] # the added mass [kg]
        self.Jlcom  = np.diag(sysm_para[1:4]) # rotational inertia of m1 about its Geometric Center (GC)
        self.ml     = self.m1 + self.m2
        # Payload's state and control
        self.pl     = SX.sym('pl',3,1) # position of center-of-mass (COM) of the payload in {I}
        self.vl     = SX.sym('vl',3,1) # velocity of CO in {I}
        self.ql     = SX.sym('ql',4,1) # quaternion of payload
        self.wl     = SX.sym('wl',3,1) # angular velocity in {Bl}
        self.xl     = vertcat(self.pl, self.vl, self.ql, self.wl) # 13-by-1 vector
        self.nxl    = self.xl.numel()
        self.Fl     = SX.sym('Fl',3,1) # total control force in {I}, generated by all the tension forces
        self.Ml     = SX.sym('Ml',3,1) # total control torque in {Bl}, generated by all the tension forces
        self.ul     = vertcat(self.Fl,self.Ml) # control wrench, 6-by-1 vector
        self.nul    = self.ul.numel()
        # Cable's state and control
        self.di     = SX.sym('di',3,1)   # cable direction in {I}, its norm = 1, pointing from the load to each quadrotor
        self.wi     = SX.sym('wi',3,1)   # cable angular velocity
        self.dwi    = SX.sym('dwi',3,1)  # cable angular acceleration
        self.ti     = SX.sym('ti',1)     # tension magnitude
        self.vti    = SX.sym('vti',1)    # tension magnitude 1st order time-derivative
        self.xi     = vertcat(self.di,self.wi,self.ti,self.vti) # 8-by-1 vector
        self.nxi    = self.xi.numel()
        self.ati     = SX.sym('ati',1)     # tension magnitude 2nd order time-derivative
        self.ui     = vertcat(self.dwi,self.ati) # cable control, 4-by-1 vector
        self.nui    = self.ui.numel()
        # Gravitational acceleration 
        self.g      = 9.81
        # Unit direction vectors free of coordinate
        self.ex     = vertcat(1, 0, 0)
        self.ey     = vertcat(0, 1, 0)
        self.ez     = vertcat(0, 0, 1)
        # Simulation time step used in MPC
        self.dt     = dt_sample
        # Polynomial coefficients of reference trajectory
        self.polyc = SX.sym('c',1,8)
        # Time in polynomial
        self.time  = SX.sym('t')
        # Initial time in polynomial
        self.time0 = SX.sym('t0')
    
    def Rotational_Inertia(self,rp):
        # rp=(x,y,0), a column vector, is the coordinate of the point-mass added on the uniform circular plate in its body frame 
        ratio_m    = self.m1*self.m2/self.ml
        self.Jl    = self.Jlcom + ratio_m*(rp.T@rp*np.identity(3)-rp@rp.T)

    def dir_cosine(self, Euler):
        # Euler angles for roll, pitch and yaw
        roll, pitch, yaw = Euler[0,0], Euler[1,0], Euler[2,0]
        # below rotation matrice are used to convert a vector from body frame to world frame
        Rx  = vertcat(
            horzcat(1,0,0),
            horzcat(0,cos(roll),-sin(roll)),
            horzcat(0,sin(roll),cos(roll))
        ) # rotation about x axis that converts a vector in {B} to {I}
        Ry  = vertcat(
            horzcat(cos(pitch),0,sin(pitch)),
            horzcat(0,1,0),
            horzcat(-sin(pitch),0,cos(pitch))
        ) # rotation about y axis that converts a vector in {B} to {I}
        Rz  = vertcat(
            horzcat(cos(yaw),-sin(yaw),0),
            horzcat(sin(yaw),cos(yaw),0),
            horzcat(0,0,1)
        ) # rotation about z axis that converts a vector in {B} to {I}
        # 3-2-1 rotation sequence that rotates the basis of {I} to the basis of {B}.
        # In other words, a body frame is obtained by rotating {I} through the 3-2-1 rotation sequence
        R_wb = Rx.T@Ry.T@Rz.T # rotation matrix that transfers a vector (e.g., a basis) in {I} to {B}
        R_bw = R_wb.T       # rotation matrix that transfers a vector in {B} to {I}

        return R_bw

    def skew_sym(self, v): # skew-symmetric operator
        v_cross = vertcat(
            horzcat(0, -v[2,0], v[1,0]),
            horzcat(v[2,0], 0, -v[0,0]),
            horzcat(-v[1,0], v[0,0], 0)
        )
        return v_cross
    
    def q_2_rotation(self, q): # from body frame to inertial frame
        q0, q1, q2, q3 = q[0,0], q[1,0], q[2,0], q[3,0] # q0 denotes a scalar while q1, q2, and q3 represent rotational axes x, y, and z, respectively
        R = vertcat(
        horzcat( 2 * (q0 ** 2 + q1 ** 2) - 1, 2 * q1 * q2 - 2 * q0 * q3, 2 * q0 * q2 + 2 * q1 * q3),
        horzcat(2 * q0 * q3 + 2 * q1 * q2, 2 * (q0 ** 2 + q2 ** 2) - 1, 2 * q2 * q3 - 2 * q0 * q1),
        horzcat(2 * q1 * q3 - 2 * q0 * q2, 2 * q0 * q1 + 2 * q2 * q3, 2 * (q0 ** 2 + q3 ** 2) - 1)
        )
        return R
    
    def payload_dyn(self, xl, ul):
        """
        Use the following cable attachment settings:
        configuration of the payload tether attachment points:
        start from the first point [rl;0;0]
        allocate the remaining attachment points anticlockwisely
        the separation angle between any two neighbouring attachment points is defined by alpha = 2*pi/nq
        the coordinate of the n-th attachment point is [rl*cos((n-1)*alpha);rl*sin((n-1)*alpha);0]
        ----------------------------------------------------------------------------------------
        We temporarily treat the load as a 6-DoF rigid body controlled by a 6-by-1 wrench vector
        """
        """
        6-DOF Rigid body dyanmics about the COM
        """
        # Position in {I}
        pl      = vertcat(xl[0,0], xl[1,0], xl[2,0])
        # Velocity in {I}
        vl      = vertcat(xl[3,0], xl[4,0], xl[5,0])
        # Quaternion
        ql      = vertcat(xl[6,0], xl[7,0], xl[8,0], xl[9,0])
        # Angular velocity in {Bl}
        wl      = vertcat(xl[10,0], xl[11,0], xl[12,0])
        # Cable forces and torques
        Fl      = vertcat(ul[0,0], ul[1,0], ul[2,0]) # in {I}
        Mtl     = vertcat(ul[3,0], ul[4,0], ul[5,0])
        # Kinematics
        dpl     = vl
        dvl     = -self.g*self.ez + 1/self.ml * Fl # model defined at the COM
        S_wl    = self.skew_sym(wl)
        omega   = vertcat(
            horzcat(0, -wl.T),
            horzcat(wl,-S_wl)
        )
        dql     = 1/2*omega@ql
        dwl     = LA.inv(self.Jl)@(Mtl-S_wl@(self.Jl@wl))
        # Model
        model_l = vertcat(dpl, dvl, dql, dwl)

        return model_l
    

    def cable_dyn(self, xi, ui):
        # cable direction in {I}
        di      = vertcat(xi[0,0], xi[1,0], xi[2,0])
        # cable angular velocity 
        wi      = vertcat(xi[3,0], xi[4,0], xi[5,0])
        # cable tension magnitude
        ti      = xi[6,0]
        # cable tension magnitude time-derivative
        dti     = xi[7,0]
        # control inputs for the cable dynamics
        dwi      = vertcat(ui[0,0], ui[1,0], ui[2,0]) # cable angular snap/jerk
        ati      = ui[3,0] # cable tension second-order/1st order time-derivative
        S_wi    = self.skew_sym(wi)
        # Kinematics and dynamics
        di_dot  = S_wi@di
        wi_dot  = dwi
        ti_dot  = dti
        ti_ddot = ati
        model_i = vertcat(di_dot,wi_dot,ti_dot,ti_ddot)

        return model_i


    def model(self):
        # Payload: 4-th order Runge-Kutta discretization of the model used in MPC (symbolic computation)
        k1l     = self.payload_dyn(self.xl, self.ul) 
        k2l     = self.payload_dyn(self.xl + self.dt/2*k1l, self.ul)
        k3l     = self.payload_dyn(self.xl + self.dt/2*k2l, self.ul)
        k4l     = self.payload_dyn(self.xl + self.dt*k3l, self.ul)
        self.dyn_l   = k1l # load dynamics used in ACADOS
        self.model_l = (k1l + 2*k2l + 2*k3l + k4l)/6
        # Cable: 4-th order Runge-Kutta discretization of the model used in MPC (symbolic computation)
        k1i     = self.cable_dyn(self.xi, self.ui)
        k2i     = self.cable_dyn(self.xi + self.dt/2*k1i, self.ui)
        k3i     = self.cable_dyn(self.xi + self.dt/2*k2i, self.ui)
        k4i     = self.cable_dyn(self.xi + self.dt*k3i, self.ui)
        self.dyn_i   = k1i # cable dynamics used in ACADOS
        self.model_i = (k1i + 2*k2i + 2*k3i + k4i)/6



    # polynomial trajectories
    def polytraj(self,coeff,time,time0):
        time_vec   = vertcat(1,
                             self.time-self.time0,
                             (self.time-self.time0)**2,
                             (self.time-self.time0)**3,
                             (self.time-self.time0)**4,
                             (self.time-self.time0)**5,
                             (self.time-self.time0)**6,
                             (self.time-self.time0)**7)
        polyp      = mtimes(self.polyc, time_vec)
        polyp_fn   = Function('ref_p',[self.polyc,self.time,self.time0],[polyp],['pc0','t0','ti0'],['ref_pf'])
        ref_p      = polyp_fn(pc0=coeff,t0=time,ti0=time0)['ref_pf'].full()
        polyv      = jacobian(polyp, self.time)
        polyv_fn   = Function('ref_v',[self.polyc,self.time,self.time0],[polyv],['pc0','t0','ti0'],['ref_vf'])
        ref_v      = polyv_fn(pc0=coeff,t0=time,ti0=time0)['ref_vf'].full()
        polya      = jacobian(polyv, self.time)
        polya_fn   = Function('ref_a',[self.polyc,self.time,self.time0],[polya],['pc0','t0','ti0'],['ref_af'])
        ref_a      = polya_fn(pc0=coeff,t0=time,ti0=time0)['ref_af'].full()
        polyj      = jacobian(polya, self.time)
        polyj_fn   = Function('ref_j',[self.polyc,self.time,self.time0],[polyj],['pc0','t0','ti0'],['ref_jf'])
        ref_j      = polyj_fn(pc0=coeff,t0=time,ti0=time0)['ref_jf'].full()
        polys      = jacobian(polyj, self.time)
        polys_fn   = Function('ref_s',[self.polyc,self.time,self.time0],[polys],['pc0','t0','ti0'],['ref_sf'])
        ref_s      = polys_fn(pc0=coeff,t0=time,ti0=time0)['ref_sf'].full()

        return ref_p, ref_v, ref_a, ref_j, ref_s
    

    def minisnap_load_circle(self,Coeffx,Coeffy,Coeffz,time,rg):
        t_switch = 0
        t1 = 2.4
        # t2 = t1+1
        if time <t1:
            ref_px, ref_vx, ref_ax, ref_jx, ref_sx = self.polytraj(Coeffx[0,:],time,t_switch)
            ref_py, ref_vy, ref_ay, ref_jy, ref_sy = self.polytraj(Coeffy[0,:],time,t_switch)
            ref_pz, ref_vz, ref_az, ref_jz, ref_sz = self.polytraj(Coeffz[0,:],time,t_switch)
        else:
            ref_px, ref_vx, ref_ax, ref_jx, ref_sx = self.polytraj(Coeffx[1,:],time,t1+t_switch)
            ref_py, ref_vy, ref_ay, ref_jy, ref_sy = self.polytraj(Coeffy[1,:],time,t1+t_switch)
            ref_pz, ref_vz, ref_az, ref_jz, ref_sz = self.polytraj(Coeffz[1,:],time,t1+t_switch)
        ref_p = np.reshape(np.vstack((ref_px, ref_py, ref_pz)), (3,1))+np.reshape(np.vstack((rg[0],rg[1],0)),(3,1))
        ref_v = np.reshape(np.vstack((ref_vx, ref_vy, ref_vz)), (3,1))
        ref_q = np.array([[1,0,0,0]]).T
        ref_w = np.zeros((3,1))
        ref_xl= np.reshape(np.vstack((ref_p,ref_v,ref_q,ref_w)),self.nxl)
        ref_a = np.reshape(np.vstack((ref_ax, ref_ay, ref_az)), (3,1))
        ref_Fl= self.ml*(ref_a + self.g*self.ez) # reference force in world frame frame (Rl = identity matrix)
        ref_ml= np.zeros((3,1)) # reference torque in the load's desired body frame
        ref_ul= np.reshape(np.vstack((ref_Fl,ref_ml)),self.nul)
        return ref_xl, ref_ul
    

    
    